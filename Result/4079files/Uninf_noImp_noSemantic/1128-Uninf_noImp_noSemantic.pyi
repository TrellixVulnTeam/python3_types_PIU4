from abc import abstractmethod
from enum import Enum
from numpy import ndarray
from pathlib import Path
from typing import Any, Callable, List, Optional, Tuple

class SpectrogramFrequencyScale(Enum):
    linear: str = ...
    mel: str = ...

class SpectrogramType(Enum):
    power: str = ...
    amplitude: str = ...
    power_level: str = ...

def z_normalize(array: ndarray) -> ndarray: ...

class PositionalLabel:
    labeled_sections: Any = ...
    labels: Any = ...
    label: Any = ...
    def __init__(self, labeled_sections: List[Tuple[str, Tuple[float, float]]]) -> None: ...
    def convert_range_to_seconds(self, original_sample_rate: int) -> PositionalLabel: ...
    def with_corrected_labels(self, correction: Callable[[str], str]) -> PositionalLabel: ...
    def serialize(self) -> str: ...
    @staticmethod
    def deserialize(serialized: str) -> PositionalLabel: ...

class LabeledSpectrogram:
    __metaclass__: Any = ...
    label: Any = ...
    id: Any = ...
    def __init__(self, id: str, label: str) -> None: ...
    @abstractmethod
    def z_normalized_transposed_spectrogram(self) -> ndarray: ...

class LabeledExample(LabeledSpectrogram):
    get_raw_audio: Any = ...
    sample_rate: Any = ...
    fourier_window_length: Any = ...
    hop_length: Any = ...
    mel_frequency_count: Any = ...
    label_with_tags: Any = ...
    positional_label: Any = ...
    def __init__(self, get_raw_audio: Callable[[], ndarray], sample_rate: int=..., id: Optional[str]=..., label: Optional[str]=..., fourier_window_length: int=..., hop_length: int=..., mel_frequency_count: int=..., label_with_tags: str=..., positional_label: Optional[PositionalLabel]=...) -> None: ...
    def tag_count(self, tag: str) -> int: ...
    def _power_spectrogram(self) -> ndarray: ...
    def _amplitude_spectrogram(self) -> ndarray: ...
    def _complex_spectrogram(self) -> ndarray: ...
    def mel_frequencies(self) -> List[float]: ...
    def _convert_spectrogram_to_mel_scale(self, linear_frequency_spectrogram: ndarray) -> ndarray: ...
    def highest_detectable_frequency(self) -> float: ...
    def spectrogram(self, type: SpectrogramType=..., frequency_scale: SpectrogramFrequencyScale=...) -> ndarray: ...
    def z_normalized_transposed_spectrogram(self): ...
    def frequency_count_from_spectrogram(self, spectrogram: ndarray) -> int: ...
    def time_step_count(self) -> int: ...
    def time_step_rate(self) -> float: ...
    @staticmethod
    def _power_level_from_power_spectrogram(spectrogram: ndarray) -> ndarray: ...
    def reconstructed_audio_from_spectrogram(self) -> ndarray: ...
    def duration_in_s(self) -> float: ...
    def __str__(self) -> str: ...

class LabeledExampleFromFile(LabeledExample):
    audio_file: Any = ...
    def __init__(self, audio_file: Path, id: Optional[str]=..., sample_rate_to_convert_to: int=..., label: Optional[str]=..., fourier_window_length: int=..., hop_length: int=..., mel_frequency_count: int=..., label_with_tags: str=..., positional_label: Optional[PositionalLabel]=...): ...
    @property
    def audio_directory(self): ...
    def original_sample_rate(self) -> int: ...
    @staticmethod
    def file_sample_rate(audio_file: Path) -> int: ...
    def duration_in_s(self) -> float: ...
    def sections(self) -> Optional[List[LabeledExample]]: ...

class CachedLabeledSpectrogram(LabeledSpectrogram):
    original: Any = ...
    spectrogram_cache_file: Any = ...
    def __init__(self, original: LabeledSpectrogram, spectrogram_cache_directory: Path) -> None: ...
    def z_normalized_transposed_spectrogram(self) -> ndarray: ...
    def _load_from_cache(self): ...
    def _calculate_and_save_spectrogram(self): ...
    def _save_to_cache(self, spectrogram: ndarray) -> Any: ...
    def is_cached(self): ...
    def repair_cached_file_if_incorrect(self) -> None: ...
    def move_incorrect_cached_file_to_backup_location_and_save_error(self, error_text: str) -> Any: ...
