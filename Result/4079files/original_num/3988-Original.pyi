# (generated with --quick)

import collections
import io
from typing import Any, Callable, Dict, Generator, Iterable, Pattern, Sized, Tuple, Type, TypeVar, Union

ModeToken = `namedtuple-CLDRMode-name-direction-required`

Alt: str
BAD_UNICODE_CATS: Tuple[str, str, str]
Both: str
CP_REGEX: Pattern[str]
Caps: str
Ctrl: str
ENTITY_REGEX: Pattern[str]
Left: str
OSXCommand: str
OrderedDict: Type[collections.OrderedDict]
Right: str
Shift: str
StringIO: Type[io.StringIO]
SubElement: Any
TOKENS: Dict[str, str]
app: str
datetime: module
get_logger: Any
itertools: module
logger: Any
lxml: Any
os: module
re: module
sys: module
unicodedata: module

_Tnamedtuple-CLDRMode-name-direction-required = TypeVar('_Tnamedtuple-CLDRMode-name-direction-required', bound=`namedtuple-CLDRMode-name-direction-required`)

class CLDRKeyboard:
    _comments: dict
    _deadkey_set: set
    _deadkeys: collections.OrderedDict[Any, set]
    _filename: Any
    _internal_name: Any
    _key_set: Any
    _locale: Any
    _modes: collections.OrderedDict[Any, collections.OrderedDict]
    _name: Any
    _space: collections.OrderedDict
    _transforms: collections.OrderedDict
    def __init__(self, data, filename = ...) -> None: ...
    def _as_yaml_transforms(self, x) -> None: ...
    def _generate_keyset(self, tree) -> None: ...
    def _parse_keymaps(self, tree) -> None: ...
    def _parse_transforms(self, tree) -> None: ...
    def as_yaml(self) -> str: ...
    @classmethod
    def from_file(cls, f) -> Any: ...
    def keys(self, mode) -> collections.OrderedDict: ...

class CLDRMode:
    _kbdgen: Any
    _raw: Any
    cldr: Any
    kbdgen: Any
    def __init__(self, data) -> None: ...
    def _init_kbdgen(self) -> Tuple[str, ...]: ...
    def _parse_tokens(self, tokens) -> tuple: ...

class UnknownNgramException(Exception): ...

class `namedtuple-CLDRMode-name-direction-required`(tuple):
    __slots__ = ["direction", "name", "required"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str, str]
    direction: Any
    name: Any
    required: Any
    def __getnewargs__(self) -> Tuple[Any, Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-CLDRMode-name-direction-required`], name, direction, required) -> `_Tnamedtuple-CLDRMode-name-direction-required`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-CLDRMode-name-direction-required`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-CLDRMode-name-direction-required`: ...
    def _replace(self: `_Tnamedtuple-CLDRMode-name-direction-required`, **kwds) -> `_Tnamedtuple-CLDRMode-name-direction-required`: ...

def cell_range(ch, from_, to_) -> Generator[str, Any, None]: ...
def cldr2kbdgen_main() -> None: ...
def cldr_sub(value, repl, ignore_space = ...) -> str: ...
def decode_u(v, newlines = ...) -> str: ...
def encode_u(v) -> str: ...
def filtered(v) -> Any: ...
def is_full_layout(o) -> bool: ...
def is_relevant_cell(x) -> bool: ...
def kbdgen2cldr_main() -> None: ...
def key_cmp(x) -> int: ...
def keyboard_range() -> itertools.chain[nothing]: ...
def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool = ..., rename: bool = ...) -> type: ...
def parse_cell(x) -> Tuple[Any, int]: ...
def process_value(*args) -> Any: ...
def split_for_set(s, string) -> tuple: ...
def to_xml(yaml_tree) -> str: ...
