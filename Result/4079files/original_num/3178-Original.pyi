# (generated with --quick)

import collections
import typing
from typing import Any, Callable, Dict, Iterable, List, Optional, Sized, Tuple, Type, TypeVar, Union

Counter: Type[typing.Counter]
DecisionTree: Type[Union[Leaf, Split]]
defaultdict: Type[collections.defaultdict]
hiring_tree: Split
inputs: List[Candidate]
key: str
math: module
senior_inputs: List[Candidate]
tree: Union[Leaf, Split]

T = TypeVar('T')
_TCandidate = TypeVar('_TCandidate', bound=Candidate)
_TLeaf = TypeVar('_TLeaf', bound=Leaf)
_TSplit = TypeVar('_TSplit', bound=Split)

class Candidate(tuple):
    __slots__ = ["did_well", "lang", "level", "phd", "tweets"]
    __dict__: collections.OrderedDict[str, Optional[Union[bool, str]]]
    _field_defaults: collections.OrderedDict[str, Optional[Union[bool, str]]]
    _field_types: collections.OrderedDict[str, type]
    _fields: Tuple[str, str, str, str, str]
    did_well: Optional[bool]
    lang: str
    level: str
    phd: bool
    tweets: bool
    def __getnewargs__(self) -> Tuple[str, str, bool, bool, Optional[bool]]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[_TCandidate], level: str, lang: str, tweets: bool, phd: bool, did_well: bool = ...) -> _TCandidate: ...
    def _asdict(self) -> collections.OrderedDict[str, Optional[Union[bool, str]]]: ...
    @classmethod
    def _make(cls: Type[_TCandidate], iterable: Iterable[Union[bool, str]], new = ..., len: Callable[[Sized], int] = ...) -> _TCandidate: ...
    def _replace(self: _TCandidate, **kwds: Union[bool, str]) -> _TCandidate: ...

class Leaf(tuple):
    __slots__ = ["value"]
    __dict__: collections.OrderedDict[str, Any]
    _field_defaults: collections.OrderedDict[str, Any]
    _field_types: collections.OrderedDict[str, type]
    _fields: Tuple[str]
    value: Any
    def __getnewargs__(self) -> Tuple[Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[_TLeaf], value) -> _TLeaf: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[_TLeaf], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> _TLeaf: ...
    def _replace(self: _TLeaf, **kwds) -> _TLeaf: ...

class Split(tuple):
    __slots__ = ["attribute", "default_value", "subtrees"]
    __dict__: collections.OrderedDict[str, Any]
    _field_defaults: collections.OrderedDict[str, Any]
    _field_types: collections.OrderedDict[str, type]
    _fields: Tuple[str, str, str]
    attribute: str
    default_value: Any
    subtrees: dict
    def __getnewargs__(self) -> Tuple[str, dict, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[_TSplit], attribute: str, subtrees: dict, default_value = ...) -> _TSplit: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[_TSplit], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> _TSplit: ...
    def _replace(self: _TSplit, **kwds) -> _TSplit: ...

def build_tree_id3(inputs: list, split_attributes: List[str], target_attribute: str) -> Union[Leaf, Split]: ...
def class_probabilities(labels: list) -> List[float]: ...
def classify(tree: Union[Leaf, Split], input) -> Any: ...
def data_entropy(labels: list) -> float: ...
def entropy(class_probabilities: List[float]) -> float: ...
def partition_by(inputs: List[T], attribute: str) -> Dict[Any, List[T]]: ...
def partition_entropy(subsets: List[list]) -> float: ...
def partition_entropy_by(inputs: list, attribute: str, label_attribute: str) -> float: ...
