# (generated with --quick)

import __future__
from typing import Any, Dict, List, Tuple, Union

OVERALL_SLICE_NAME: Any
SingleSliceSpec: Any
absolute_import: __future__._Feature
constants: Any
division: __future__._Feature
model_eval_lib: Any
os: module
print_function: __future__._Feature
testutil: Any
tf: Any
util: Any

class UtilTest(Any):
    base_data_location_2: str
    base_model_location_2: str
    column_1: str
    column_2: str
    column_a: str
    column_b: str
    column_c: str
    column_d: str
    data_location_1: str
    full_data_location_2: str
    full_model_location_2: str
    key: str
    metrics_a: Dict[str, int]
    metrics_aggregate: Dict[str, int]
    metrics_b: Dict[str, int]
    metrics_c: Dict[str, int]
    metrics_c2: Dict[str, int]
    metrics_d: Dict[str, int]
    model_location_1: str
    plots_a: Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, int]]]]]]
    plots_b: Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]]
    plots_b2: Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]]
    plots_c: Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, Union[float, str]]]]]]]
    plots_c2: Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]]
    plots_data_a: Dict[str, Dict[str, Dict[str, List[Dict[str, int]]]]]
    plots_data_b: Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]
    plots_data_b2: Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]
    plots_data_c: Dict[str, Dict[str, Dict[str, List[Dict[str, Union[float, str]]]]]]
    plots_data_c2: Dict[str, Dict[str, Dict[str, List[Dict[str, float]]]]]
    result_a: Tuple[List[Tuple[str, str]], Dict[str, int]]
    result_aggregate: Tuple[List[nothing], Dict[str, int]]
    result_b: Tuple[List[Tuple[str, str]], Dict[str, int]]
    result_c: Tuple[List[Tuple[str, str]], Dict[str, int]]
    result_c2: Tuple[List[Tuple[str, str]], Dict[str, int]]
    result_d: Tuple[List[Tuple[str, str]], Dict[str, int]]
    slice_a: str
    slice_b: str
    slice_c: str
    slice_d: str
    def _makeEvalConfig(self) -> Any: ...
    def _makeEvalResults(self) -> Any: ...
    def _makeTestData(self) -> List[Tuple[List[Tuple[str, str]], Dict[str, int]]]: ...
    def _makeTestPlotsData(self) -> List[Tuple[List[Tuple[str, str]], Dict[str, Dict[str, Dict[str, List[Dict[str, Union[float, int, str]]]]]]]]: ...
    def testDisplayFullPathForTimeSeries(self) -> None: ...
    def testFilterColumnCrossFeatrueResultBySpec(self) -> None: ...
    def testFilterColumnResultBySpec(self) -> None: ...
    def testFilterEvalResultsForTimeSeries(self) -> None: ...
    def testFilterFeatrueCrossResultBySpec(self) -> None: ...
    def testFilterFeatrueResultBySpec(self) -> None: ...
    def testGetAggregateMetrics(self) -> None: ...
    def testGetPlotDataAndConfig(self) -> None: ...
    def testGetPlotUsingLabel(self) -> None: ...
    def testGetSlicingConfig(self) -> None: ...
    def testGetSlicingMetrics(self) -> None: ...
    def testOverrideWeightColumnForSlicingMetricsView(self) -> None: ...
    def testRaisesErrorWhenAggregateNotAvailable(self) -> None: ...
    def testRaisesErrorWhenColumnNotAvailable(self) -> None: ...
    def testRaisesErrorWhenLabelNotProvided(self) -> None: ...
    def testRaisesErrorWhenMoreThanOneAggregateAvailable(self) -> None: ...
    def testRaisesErrorWhenMultipleMatchForLabel(self) -> None: ...
    def testRaisesErrorWhenMultipleSlicesMatchInPlotData(self) -> None: ...
    def testRaisesErrorWhenNoMatchAvailableInPlotData(self) -> None: ...
    def testRaisesErrorWhenNoMatchAvailableInTimeSeries(self) -> None: ...
    def testRaisesErrorWhenNoMatchForLabel(self) -> None: ...
    def testRaisesErrorWhenToomManyMatchesAvailableInTimeSeries(self) -> None: ...
    def testReplaceNaNInPlotWithNone(self) -> None: ...
