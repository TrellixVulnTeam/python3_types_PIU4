# (generated with --quick)

import __builtin__
from typing import Any, Callable, Dict, Iterable, List, Optional, Sized, Tuple, TypeVar

EdgesData = List[Tuple[int, int, int]]
GoalsData = List[Tuple[int, Optional[str], bool]]
OptionsData = List[Tuple[str, int]]

Graph: Any
collections: module

_Tnamedtuple-Edge-source-target-type = TypeVar('_Tnamedtuple-Edge-source-target-type', bound=`namedtuple-Edge-source-target-type`)

class Edge(`namedtuple-Edge-source-target-type`):
    __slots__ = []
    BLOCKER: int
    PARENT: int

class Goals(Any):
    closed: set
    edges: Any
    events: collections.deque
    goals: Dict[int, Optional[str]]
    message_fn: Any
    settings: dict
    def __init__(self, name: str, message_fn: Optional[Callable[[str], None]] = ...) -> None: ...
    def _add_no_link(self, name: str) -> int: ...
    def _back_edges(self, goal: int) -> List[Edge]: ...
    def _create_new_link(self, lower: int, upper: int, edge_type: int) -> None: ...
    def _delete(self, goal_id: int) -> None: ...
    def _forward_edges(self, goal: int) -> List[Edge]: ...
    def _has_circular_dependency(self, lower: int, upper: int) -> bool: ...
    def _has_link(self, lower: int, upper: int) -> bool: ...
    def _may_be_closed(self) -> bool: ...
    def _may_be_reopened(self) -> bool: ...
    def _msg(self, message: str) -> None: ...
    def _remove_existing_link(self, lower: int, upper: int, edge_type: Optional[int] = ...) -> None: ...
    def _replace_link(self, lower: int, upper: int, edge_type: int) -> None: ...
    def _switchable(self, key: int) -> bool: ...
    def _transform_old_parents_into_blocked(self, lower, upper) -> None: ...
    def add(self, name: str, add_to: int = ..., edge_type: int = ...) -> bool: ...
    @staticmethod
    def build(goals: List[Tuple[int, Optional[str], bool]], edges: List[Tuple[int, int, int]], settings: List[Tuple[str, int]], message_fn: Optional[Callable[[str], None]] = ...) -> Goals: ...
    def delete(self, goal_id: int = ...) -> None: ...
    @staticmethod
    def export(goals: Goals) -> Tuple[List[Tuple[int, Optional[str], bool]], List[Tuple[int, int, int]], List[Tuple[str, int]]]: ...
    def hold_select(self) -> None: ...
    def insert(self, name: str) -> None: ...
    def q(self, keys: str = ...) -> Dict[int, Any]: ...
    def rename(self, new_name: str, goal_id: int = ...) -> None: ...
    def select(self, goal_id: int) -> None: ...
    def toggle_close(self) -> None: ...
    def toggle_link(self, lower: int = ..., upper: int = ..., edge_type: int = ...) -> None: ...
    def verify(self) -> bool: ...

class `namedtuple-Edge-source-target-type`(tuple):
    __slots__ = ["source", "target", "type"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str, str]
    source: Any
    target: Any
    type: Any
    def __getnewargs__(self) -> Tuple[Any, Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: __builtin__.type[`_Tnamedtuple-Edge-source-target-type`], source, target, type) -> `_Tnamedtuple-Edge-source-target-type`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: __builtin__.type[`_Tnamedtuple-Edge-source-target-type`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-Edge-source-target-type`: ...
    def _replace(self: `_Tnamedtuple-Edge-source-target-type`, **kwds) -> `_Tnamedtuple-Edge-source-target-type`: ...
