# (generated with --quick)

import requests.models
from typing import Any, Dict, List, Optional, Type, TypeVar, Union

ERROR_KIND: str
HttpResponse: Type[requests.models.Response]
WARNING_KIND: str
cli: Any
flask: module
logger: Any
threads: Any
typing: module

_TResponse = TypeVar('_TResponse', bound=Response)
_TResponseMessage = TypeVar('_TResponseMessage', bound=ResponseMessage)

class Response(object):
    __doc__: str
    data: Dict[str, Any]
    ended: Any
    errors: list
    failed: Any
    http_response: requests.models.Response
    identifier: Any
    messages: list
    parent: Response
    response: Any
    returned: None
    success: bool
    thread: Any
    warnings: list
    def __init__(self, identifier: Optional[str] = ..., failed = ...) -> None: ...
    def consume(self: _TResponse, other: Union[ResponseMessage, _TResponse]) -> _TResponse: ...
    def debug_echo(self: _TResponse) -> _TResponse: ...
    @staticmethod
    def deserialize(serial_data: dict) -> Response: ...
    def echo(self) -> str: ...
    def end(self: _TResponse) -> _TResponse: ...
    def fail(self, message: Optional[str] = ..., code: Optional[str] = ..., error: Optional[Exception] = ..., **kwargs) -> ResponseMessage: ...
    def flask_serialize(self) -> Any: ...
    def get_notification_log(self, start_index: int = ...) -> str: ...
    def get_thread_log(self) -> List[str]: ...
    def join(self, timeout: Optional[float] = ...) -> bool: ...
    def log_notifications(self, start_index: int = ..., trace: bool = ..., file_path: Optional[str] = ..., append_to_file: bool = ...) -> str: ...
    def notify(self, kind: Optional[str] = ..., message: Optional[str] = ..., code: Optional[str] = ..., **kwargs) -> ResponseMessage: ...
    def serialize(self) -> dict: ...
    def update(self: _TResponse, **kwargs) -> _TResponse: ...
    def warn(self, message: Optional[str] = ..., code: Optional[str] = ..., **kwargs) -> ResponseMessage: ...

class ResponseMessage(object):
    code: Any
    data: Any
    index: int
    kind: Any
    log: str
    message: Any
    response: Any
    def __init__(self, kind: Optional[str] = ..., code: Optional[str] = ..., message: Optional[str] = ..., response: Optional[Response] = ..., index: int = ..., log: str = ..., data: Optional[dict] = ...) -> None: ...
    def console(self: _TResponseMessage, message: Optional[Union[str, List[str]]] = ..., whitespace: int = ..., whitespace_top: int = ..., whitespace_bottom: int = ..., indent_by: int = ..., trace: bool = ..., file_path: Optional[str] = ..., append_to_file: bool = ..., **kwargs) -> _TResponseMessage: ...
    def console_header(self: _TResponseMessage, text: str, level: int = ..., whitespace: int = ..., whitespace_top: int = ..., whitespace_bottom: int = ..., trace: bool = ..., file_path: Optional[str] = ..., append_to_file: bool = ..., indent_by: int = ...) -> _TResponseMessage: ...
    def console_raw(self: _TResponseMessage, message: str, trace: bool = ..., file_path: Optional[str] = ..., append_to_file: bool = ...) -> _TResponseMessage: ...
    def get_response(self) -> Response: ...
    def kernel(self: _TResponseMessage, **kwargs) -> _TResponseMessage: ...
    def serialize(self) -> dict: ...
