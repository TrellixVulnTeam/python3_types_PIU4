# (generated with --quick)

from typing import Any, List, NoReturn, Tuple, Type

PriorityQueue: Type[util.PriorityQueue]
PriorityQueueWithFunction: Type[util.PriorityQueueWithFunction]
Queue: Type[util.Queue]
Stack: Type[util.Stack]
util: module

class Node:
    action: str
    cost: Any
    parent: Any
    state: Tuple[int, int]
    def __eq__(self, other) -> Any: ...
    def __gt__(self, other) -> Any: ...
    def __hash__(self) -> int: ...
    def __init__(self, state: Tuple[int, int], action: str, cost: int, parent) -> None: ...
    def __lt__(self, other) -> Any: ...
    def __ne__(self, other) -> bool: ...
    def __str__(self) -> str: ...
    def get_path(self) -> List[str]: ...
    def parent_state(self) -> Any: ...

class SearchProblem:
    __doc__: str
    def getCostOfActions(self, actions) -> NoReturn: ...
    def getStartState(self) -> NoReturn: ...
    def getSuccessors(self, state) -> NoReturn: ...
    def isGoalState(self, state) -> NoReturn: ...

def aStarSearch(problem, heuristic = ...) -> List[str]: ...
def astar(problem, heuristic = ...) -> List[str]: ...
def bfs(problem) -> List[str]: ...
def breadthFirstSearch(problem) -> List[str]: ...
def depthFirstSearch(problem) -> List[str]: ...
def dfs(problem) -> List[str]: ...
def graph_search(problem, frontier) -> List[str]: ...
def manhattanDistance(xy1, xy2) -> Any: ...
def manhattanHeuristic(state, problem = ...) -> Any: ...
def nullHeuristic(state, problem = ...) -> int: ...
def tinyMazeSearch(problem) -> list: ...
def ucs(problem) -> List[str]: ...
def uniformCostSearch(problem) -> List[str]: ...
