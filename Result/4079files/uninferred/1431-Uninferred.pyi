import unittest
from collections import namedtuple
from typing import Any, Optional

class TestAnnotatedDocsForMethodSignatures(unittest.TestCase):
    def test_only_functions_classes_and_and_methods_are_considered(self) -> None: ...
    def __assert_signature_docs_override(self, expected_override: Any, type_str: Any, fully_qualified_name_suffix: Any, obj: Any) -> None: ...
    def test_when_there_are_no_annots_then_sign_docs_are_not_overridden(self) -> None: ...
    def test_when_args_have_annots_then_signature_docs_are_overridden(self) -> None: ...
    def test_when_retval_has_annot_then_signature_docs_are_overridden(self) -> None: ...
    def test_class_signatures_are_overridden_according_to_their_init(self) -> None: ...
    def test_cls_sign_are_not_overridden_when_their_init_dont_cont_annot(self) -> None: ...
    def test_default_values_are_added_to_positional_args(self) -> None: ...
    def test_first_arg_of_methods_is_ign_even_if_it_has_a_default_value(self) -> None: ...
    def test_default_value_can_be_complex(self) -> None: ...
    def test_mixed_types_are_represented_as_tuples(self) -> None: ...
    def test_string_annotations_dont_cause_infinite_recursion(self) -> None: ...
    def test_varargs_are_added_into_the_signature_when_present(self) -> None: ...
    def test_varargs_can_be_annotated(self) -> None: ...
    def test_kwonly_args_are_appended_after_an_asterisk(self) -> None: ...
    def test_class_names_are_fully_qualified(self) -> None: ...
    def test_type_annotations_can_be_functions(self) -> None: ...
    def test_type_annotations_can_be_named_tuples(self) -> None: ...
    def test_decorated_methods_are_resolved_when_decor_func_attr_is_set(self) -> None: ...
    def test_decorated_methods_dont_trigger_inf_loop_but_return_none(self) -> None: ...
    def test_decorated_methods_should_not_trigger_errors_but_return_none(self) -> None: ...
    def test_integration(self) -> None: ...

class SomeClass:
    def __init__(self) -> None: ...

class SomeOtherClass:
    def __init__(self) -> None: ...

SomeNamedTuple = namedtuple('SomeNamedTuple', 'x')

def function_without_annotations(an_int: Any) -> None: ...
def function_with_return_annotation_only() -> str: ...
def function_with_mixed_types(something: Tuple[None, int]=...) -> Tuple[int, None]: ...
def function_with_named_tuple(a_tuple: SomeNamedTuple) -> Any: ...
def function_with_annotated_varargs(an_int: Any, *varargs: list, **varkwargs: dict) -> Any: ...
def function_with_complex_default_value(a_tuple: tuple=...) -> Any: ...
def function_with_string_annotation(an_arg: 'some string') -> Any: ...
def some_decorator(func: Any): ...
def recursive_decorator(func: Any): ...
def messed_up_decorator(func: Any): ...

class ExampleClass:
    @classmethod
    def classmethod_with_builtin_type_annotations(cls: Any, an_int: int) -> Any: ...
    def __init__(self, an_int: int) -> None: ...
    def method_with_default_value(self, a_float: float, an_int: int=..., an_str: str=...) -> Any: ...
    def method_with_varargs(self, an_int: int, *varargs: Any, **varkwargs: Any) -> Any: ...
    def method_with_kwonly_arg(self, a_float: float, an_int: int) -> Any: ...
    def method_with_default_value_for_self(self: Optional[Any] = ..., an_int: int=...) -> Any: ...
    def method_with_class_names(self, an_object: SomeClass) -> SomeClass: ...
    def method_with_function_annotations(self, a_callable: callable) -> callable: ...
    def method_with_decorators(self, an_int: int) -> str: ...
    def method_with_recursive_decorator(self, an_int: int) -> Any: ...
    def method_with_messed_up_decorator(self, an_int: int) -> Any: ...
    def integration(self, an_int: int, a_string: Tuple[None, str]=..., *, a_callable: Tuple[None, callable]=..., **kwargs: dict) -> str: ...
