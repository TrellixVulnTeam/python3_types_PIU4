from typing import Any, ByteString, Iterable, Sequence, Tuple

class NotImplementedType:
    def __getitem__(cls, x: Any): ...

def min_version_met() -> bool: ...
def have_typing_module() -> bool: ...

class Checker:
    def __init__(self, line_tail: Any) -> None: ...
    def __call__(self, binary: ByteString, console: Sequence[str]) -> Tuple[ByteString, Sequence[str]]: ...

class EmitsBytes(Checker):
    bytes: Any = ...
    def __init__(self, s: Any) -> None: ...
    def __call__(self, binary: Any, output: Any): ...

class SkipBytes(Checker):
    length: Any = ...
    def __init__(self, s: Any) -> None: ...
    def __call__(self, binary: Any, output: Any): ...

class EmitsWarning(Checker):
    warn_code: Any = ...
    def __init__(self, s: Any) -> None: ...
    def __call__(self, binary: Any, output: Any): ...

class EmitsError(Checker):
    err_code: Any = ...
    def __init__(self, s: Any) -> None: ...
    def __call__(self, binary: Any, output: Any): ...

class EmitsNonFatalError(EmitsError):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __call__(self, binary: Any, output: Any): ...

CHECK_TYPES: Any

def find_check_directives(sources: Iterable[str]) -> Sequence[Checker]: ...
def find_assembler_args(sources: Iterable[str]) -> str: ...
def run_assembler(assembler: str, infile: str, opts: str) -> Tuple[int, ByteString, Sequence[str]]: ...
def filter_whitespace(s: str) -> str: ...
def format_bytes(b: Any) -> str: ...
def main(assembler: Any, files: Iterable[str]) -> int: ...
