from pymaker import Address as Address
from typing import Any
from web3 import Web3

async def async_return(result: Any): ...
async def async_exception() -> None: ...
def mocked_web3(block_0_hash: str) -> Web3: ...
def test_chain_should_recognize_ethlive() -> None: ...
def test_chain_should_recognize_kovan() -> None: ...
def test_chain_should_recognize_ropsten() -> None: ...
def test_chain_should_recognize_morden() -> None: ...
def test_chain_should_report_unknown_chains_as_unknown() -> None: ...
def mocked_web3_transaction_count(address: Address, latest: int, pending: int) -> Web3: ...
def test_synchronize_should_return_empty_list_for_no_futures() -> None: ...
def test_synchronize_should_return_results_of_all_async_calls() -> None: ...
def test_synchronize_should_pass_exceptions() -> None: ...
def test_int_to_bytes32() -> None: ...
def test_bytes_to_int() -> None: ...
def test_bytes_to_int_from_string() -> None: ...
def test_bytes_to_int_from_int_should_fail() -> None: ...
def test_bytes_to_hexstring() -> None: ...
def test_hexstring_to_bytes() -> None: ...

class TestAsyncCallback:
    def callbacks(self): ...
    def test_should_call_callback(self, callbacks: Any) -> None: ...
    def test_should_not_call_callback_if_previous_one_is_still_running(self, callbacks: Any) -> None: ...
    def test_should_call_callback_again_if_previous_one_is_finished(self, callbacks: Any) -> None: ...
    def test_should_wait_for_the_callback_to_finish(self, callbacks: Any) -> None: ...
    def test_should_call_on_start_and_on_finish_before_and_after_the_callback(self, callbacks: Any) -> None: ...
