from .helper import EndableThreadingClass
from typing import Any

def debug_on_httplevel() -> None: ...

log: Any

def void(*dummy: Any) -> None: ...

rsession: Any

class UrlMgr:
    isStream: bool = ...
    default_base_cache_dir: Any = ...
    default_cache_class: Any = ...
    url: Any = ...
    cache: Any = ...
    position: int = ...
    __data: Any = ...
    __request: Any = ...
    __size: Any = ...
    kwargs: Any = ...
    def __init__(self, url: Any, **kwargs: Any) -> None: ...
    def initHeader(self): ...
    def initRequestArgs(self): ...
    def setCacheWriteOnly(self) -> None: ...
    def setCacheReadOnly(self) -> None: ...
    def clearCache(self) -> None: ...
    def clear_connection(self) -> None: ...
    def get_request(self): ...
    def get_data(self): ...
    def get_rawdata(self): ...
    def get_size(self): ...
    request: Any = ...
    data: Any = ...
    size: Any = ...

class LargeDownload(UrlMgr, EndableThreadingClass):
    uids: int = ...
    isStream: bool = ...
    retries: int = ...
    default_base_cache_dir: Any = ...
    default_cache_class: Any = ...
    hooks: Any = ...
    downloaded: int = ...
    save_path: str = ...
    uid: Any = ...
    isResume: bool = ...
    limit: Any = ...
    def __init__(self, url: Any, **kwargs: Any) -> None: ...
    def __str__(self): ...
    def __setattr__(self, name: Any, value: Any) -> None: ...
    def set_resume(self) -> None: ...
    def got_requested_position(self): ...
    @staticmethod
    def best_block_size(elapsed_time: Any, bytes: Any): ...
    def apply_limit(self, elapsed_time: Any, block_size: Any): ...
    position: Any = ...
    def resumeDownload(self): ...
    def downloadLoop(self, streamFile: Any) -> None: ...
    def response(self) -> None: ...
    def finished_success(self) -> None: ...
    def finished_error(self) -> None: ...
    def run(self) -> None: ...
