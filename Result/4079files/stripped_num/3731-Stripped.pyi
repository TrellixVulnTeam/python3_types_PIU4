# (generated with --quick)

from typing import AbstractSet, Any, Callable, List, NoReturn, Optional, Sequence, Type, TypeVar, Union

Random: Type[random.Random]
SystemRandom: Type[random.SystemRandom]

_T = TypeVar('_T')

class EvolvingSetting:
    setting: dict
    def __init__(self, setting) -> None: ...
    def value_in_time(self, time) -> Any: ...

class RandomSellerBase(SellerBase):
    game_len: Any
    def buying_entities(self, time) -> NoReturn: ...
    def income_coef(self, time) -> NoReturn: ...
    def max_buy_count(self, time) -> NoReturn: ...
    def max_buy_price(self, time) -> NoReturn: ...
    def max_sell_count(self, time) -> NoReturn: ...
    def max_sell_price(self, time) -> NoReturn: ...
    def selling_entities(self, time) -> NoReturn: ...

class RandomStuffRiscantSeller(RandomSellerBase):
    buying_entities: Callable[[Any], Any]
    game_len: Any
    income_coef: Callable[[Any], Any]
    max_buy_count: Callable[[Any], Any]
    max_buy_price: Callable[[Any], Any]
    max_sell_count: Callable[[Any], Any]
    max_sell_price: Callable[[Any], Any]
    max_sell_setting: EvolvingSetting
    name: str
    risks: EvolvingSetting
    selling_entities: Callable[[Any], Any]
    spans: EvolvingSetting
    def generate(self) -> None: ...

class SellerBase:
    game_len: Any
    def __init__(self) -> None: ...
    @staticmethod
    def add_auction_item(auction, entity, amount, visible = ..., will_sell = ...) -> Any: ...
    @staticmethod
    def estimate_price(auction, coef) -> int: ...
    def generate(self) -> NoReturn: ...
    def generate_one(self, time) -> NoReturn: ...
    @staticmethod
    def get_items_to_price(price, items) -> dict: ...

class StaticAuction(SellerBase):
    b: Any
    coef: Any
    estimate: bool
    game_len: Any
    def __enter__(self) -> Any: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def __init__(self, coef = ..., *args, **kwargs) -> None: ...

class TrivialSeller(SellerBase):
    game_len: Any
    def buying_entities(self, time) -> list: ...
    def income_coef(self, time) -> int: ...
    def max_buy_count(self, time) -> int: ...
    def max_buy_price(self, time) -> int: ...
    def max_sell_count(self, time) -> int: ...
    def max_sell_price(self, time) -> int: ...
    def selling_entities(self, time) -> list: ...

def __getattr__(name) -> Any: ...
def betavariate(alpha: float, beta: float) -> float: ...
def choice(seq: Sequence[_T]) -> _T: ...
def choices(population: Sequence[_T], weights: Optional[Sequence[float]] = ..., *, cum_weights: Optional[Sequence[float]] = ..., k: int = ...) -> List[_T]: ...
def e(name) -> Any: ...
def ent_filter(**kwargs) -> Any: ...
def expovariate(lambd: float) -> float: ...
def gammavariate(alpha: float, beta: float) -> float: ...
def gauss(mu: float, sigma: float) -> float: ...
def generate_blackmarket(force = ...) -> str: ...
def getrandbits(k: int) -> int: ...
def getstate() -> Any: ...
def lognormvariate(mu: float, sigma: float) -> float: ...
def normalvariate(mu: float, sigma: float) -> float: ...
def paretovariate(alpha: float) -> float: ...
def peanut_merchant() -> None: ...
def randfloat(a, b) -> Any: ...
def randint(a: int, b: int) -> int: ...
def random() -> float: ...
def randrange(start: int, stop: Optional[int] = ..., step: int = ...) -> int: ...
def sample(population: Union[AbstractSet[_T], Sequence[_T]], k: int) -> List[_T]: ...
def seed(a = ..., version: int = ...) -> None: ...
def sell_rafts_for_robots() -> None: ...
def setstate(state: object) -> None: ...
def shuffle(x: list, random: Optional[Callable[[], float]] = ...) -> None: ...
def triangular(low: float = ..., high: float = ..., mode: float = ...) -> float: ...
def uniform(a: float, b: float) -> float: ...
def vonmisesvariate(mu: float, kappa: float) -> float: ...
def weibullvariate(alpha: float, beta: float) -> float: ...
