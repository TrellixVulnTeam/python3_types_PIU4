# (generated with --quick)

import collections
import common
import requests.sessions
from typing import Any, Callable, Generator, Iterable, List, Optional, Sized, Tuple, Type, TypeVar, Union
import urllib.parse

NeulionClip = `namedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`
Project = `namedtuple-Project-id-name`

BeautifulSoup: Any
OrderedDict: Type[collections.OrderedDict]
PreparedVideoInfo: Type[common.PreparedVideoInfo]
Session: Type[requests.sessions.Session]
TimeCode: Type[common.TimeCode]
VideoMetadata: Type[common.VideoMetadata]
VideoProvider: Type[common.VideoProvider]
date: Type[datetime.date]
datetime: Type[datetime.datetime]
os: module
pendulum: Any
pytz: module
timedelta: Type[datetime.timedelta]

_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration = TypeVar('_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration', bound=`namedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`)
_Tnamedtuple-Project-id-name = TypeVar('_Tnamedtuple-Project-id-name', bound=`namedtuple-Project-id-name`)

class NeulionClipMetadata(common.VideoMetadata):
    clip_start_utc: Any
    descr: Any
    duration: datetime.timedelta
    project_id: Any
    rank: Any
    def __init__(self, clip_id, project_id, rank, title, descr, clip_start_utc, url, category = ..., timecodes = ...) -> None: ...

class NeulionScraperApi(common.VideoProvider):
    __doc__: str
    _site_soup: Any
    session: requests.sessions.Session
    tz: Any
    def __init__(self, site_url, tz = ...) -> None: ...
    def _get_site_html(self) -> Any: ...
    def allowed_dates(self) -> Generator[datetime.date, Any, None]: ...
    def available_dates(self, start_date, end_date) -> Generator[Any, Any, None]: ...
    def clips(self, for_date, project_ids) -> Generator[NeulionClipMetadata, Any, None]: ...
    def download(self, url, destination_dir) -> None: ...
    def get_metadata(self, for_date) -> Generator[Any, Any, None]: ...
    def postprocess(self, video_metadata, download_dir, destination_dir, **kwargs) -> common.PreparedVideoInfo: ...
    def projects(self) -> Generator[`namedtuple-Project-id-name`, Any, None]: ...

class `namedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`(tuple):
    __slots__ = ["descr", "duration", "id", "project", "rank", "start_utc", "title", "url"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str, str, str, str, str, str, str]
    descr: Any
    duration: Any
    id: Any
    project: Any
    rank: Any
    start_utc: Any
    title: Any
    url: Any
    def __getnewargs__(self) -> Tuple[Any, Any, Any, Any, Any, Any, Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`], url, title, rank, descr, start_utc, project, id, duration) -> `_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`: ...
    def _replace(self: `_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`, **kwds) -> `_Tnamedtuple-Clip-url-title-rank-descr-start_utc-project-id-duration`: ...

class `namedtuple-Project-id-name`(tuple):
    __slots__ = ["id", "name"]
    __dict__: collections.OrderedDict[str, Any]
    _fields: Tuple[str, str]
    id: Any
    name: Any
    def __getnewargs__(self) -> Tuple[Any, Any]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[`_Tnamedtuple-Project-id-name`], id, name) -> `_Tnamedtuple-Project-id-name`: ...
    def _asdict(self) -> collections.OrderedDict[str, Any]: ...
    @classmethod
    def _make(cls: Type[`_Tnamedtuple-Project-id-name`], iterable: Iterable, new = ..., len: Callable[[Sized], int] = ...) -> `_Tnamedtuple-Project-id-name`: ...
    def _replace(self: `_Tnamedtuple-Project-id-name`, **kwds) -> `_Tnamedtuple-Project-id-name`: ...

def adaptive_url_to_segment_urls(adaptive_url) -> Generator[str, Any, None]: ...
def calculate_timecodes(root_clip, subclips) -> collections.OrderedDict[str, Any]: ...
def download_clip(segment_urls, destination, workers) -> None: ...
def duration_to_timecode(delta) -> str: ...
def ffmpeg_concat(concat_file, video_out, mono = ..., loglevel = ...) -> None: ...
def group_all_clips_under_first_clip(clips) -> dict: ...
def group_root_and_subclips(clips) -> collections.OrderedDict[Any, list]: ...
def group_video_clips(clips) -> Union[dict, collections.OrderedDict[Any, List[nothing]]]: ...
def namedtuple(typename: str, field_names: Union[str, Iterable[str]], *, verbose: bool = ..., rename: bool = ...) -> type: ...
def parse_time_range_from_url(adaptive_url) -> Tuple[datetime.datetime, datetime.datetime, datetime.timedelta]: ...
def shift_timecodes(timecodes, relative_to) -> None: ...
def timecode_to_duration(code) -> Any: ...
@overload
def urlparse(url: str, scheme: Optional[str] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResult: ...
@overload
def urlparse(url: Optional[bytes], scheme: Optional[bytes] = ..., allow_fragments: bool = ...) -> urllib.parse.ParseResultBytes: ...
def write_ffmpeg_concat_file(segments_dir, segment_duration) -> str: ...
