# (generated with --quick)

import expression
import lexer
import statement
from typing import Any, NoReturn, Union

Exp: module
Lex: module
Stm: module
Tok: Any

class Parser(object):
    fun_depth: int
    lex: lexer.Lexer
    loop_depth: int
    path: None
    prev_tok: Any
    this_tok: Any
    def addition(self) -> Any: ...
    def assignment(self) -> Any: ...
    def block(self) -> statement.Block: ...
    def break_stm(self) -> NoReturn: ...
    def call(self) -> Any: ...
    def concat(self) -> Any: ...
    def declaration(self) -> Any: ...
    def equality(self) -> Any: ...
    def exp_stm(self) -> statement.Exp: ...
    def expression(self) -> Any: ...
    def for_cond(self) -> statement.Block: ...
    def fun_decl(self) -> statement.FunDecl: ...
    def if_cond(self) -> statement.If: ...
    def logic_and(self) -> Any: ...
    def logic_or(self) -> Any: ...
    def multiplication(self) -> Any: ...
    def ordering(self) -> Any: ...
    def parse(self, text) -> list: ...
    def primary(self) -> Union[expression.Ident, expression.Literal]: ...
    def print_stm(self) -> statement.Print: ...
    def program(self) -> list: ...
    def return_stm(self) -> statement.Return: ...
    def statement(self) -> Union[statement.Block, statement.Break, statement.Exp, statement.Return]: ...
    def tok_consume(self, kind, message) -> None: ...
    def tok_is(self, kind_arr) -> bool: ...
    def tok_matches(self, kind) -> bool: ...
    def tok_next(self) -> Any: ...
    def tok_was(self, kind) -> Any: ...
    def unary(self) -> Any: ...
    def var_decl(self) -> statement.VarDecl: ...
    def while_cond(self) -> statement.While: ...

class ParserError(Exception):
    lineno: Any
    msg: Any
    def __init__(self, lineno, msg) -> None: ...
