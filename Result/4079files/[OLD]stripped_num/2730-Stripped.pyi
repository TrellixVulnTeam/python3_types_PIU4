# (generated with --quick)

import abc
from typing import Any, Callable, Dict, Sequence, Tuple, Type, TypeVar, Union

ABCMeta: Type[abc.ABCMeta]
COMPONENT_REGISTRY: Dict[int, Component]
JSON: Any
LightQueue: Any
SEPARATOR: str
SerializationError: Any
date: Type[datetime.date]
datetime: Type[datetime.datetime]
emit: Any
eventlet: Any
flask: module
json: module
msgpack: Any
string: module
time: Type[datetime.time]

_FuncT = TypeVar('_FuncT', bound=Callable)
_T0 = TypeVar('_T0')

class Component(metaclass=_Maker):
    _ATTRS: Any
    _COMPONENT: Any
    _NEXT_UUID: int
    _PACKAGE: Any
    _TEMPLATE: Any
    __doc__: str
    _comp: None
    _instantiate: Any
    _tag: str
    _tagbase: str
    _uuid: int
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self) -> None: ...
    @staticmethod
    def _insert(wrap, tag) -> str: ...
    @classmethod
    def _next_uuid(cls) -> Any: ...

class Event:
    __doc__: str
    _key: Tuple[Any, Any, Any]
    getter: Any
    name: Any
    signal: str
    uuid: Any
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __init__(self, name, uuid, getter = ...) -> None: ...
    def __repr__(self) -> str: ...

class FormatDict(dict):
    __doc__: str
    def __missing__(self, key) -> str: ...

class _Maker(abc.ABCMeta):
    def __new__(cls, name, bases, namespace) -> Any: ...

def abstractmethod(callable: _FuncT) -> _FuncT: ...
def encoders(obj) -> Any: ...
def is_command(attribute) -> Any: ...
def is_event(attribute) -> Any: ...
def is_getter(attribute) -> Any: ...
def jdumps(data) -> str: ...
def jsbool(x) -> str: ...
def jsnull(x: _T0) -> Union[str, _T0]: ...
def json_conversion(obj) -> Any: ...
def make_command(command) -> Callable: ...
def make_event(event) -> property: ...
def make_getter(getter) -> Callable: ...
def pack(x) -> Any: ...
def unpack(x) -> Any: ...
def wraps(wrapped: Callable, assigned: Sequence[str] = ..., updated: Sequence[str] = ...) -> Callable[[Callable], Callable]: ...
