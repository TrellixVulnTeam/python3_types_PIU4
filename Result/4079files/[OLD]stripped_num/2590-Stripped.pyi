# (generated with --quick)

import codecs
import json
import json.decoder
import json.encoder
import multiprocessing.pool
import special_cases
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, MutableSequence, Optional, Pattern, Tuple, Type, TypeVar, Union

file_buffer: Dict[Any, Union[dict, list]]
files_of_interest: Any
glitchEmoteExtractor: Pattern[str]
glitchIsHere: Pattern[str]
ignore_filelist: Any
platform: str
prefix: str
root_dir: str
specialSections: List[special_cases.SpecialSection]
specialSharedPaths: Dict[str, str]
sub_file: str
textHandlers: List[Callable[[Any, Any, Any], Any]]
texts_prefix: str
thedatabase: Dict[Any, Dict[Any, Dict[str, List[nothing]]]]

AnyStr = TypeVar('AnyStr', str, bytes)
_T = TypeVar('_T')
_T0 = TypeVar('_T0')
_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')

def Pool(processes: Optional[int] = ..., initializer: Optional[Callable] = ..., initargs: Iterable = ..., maxtasksperchild: Optional[int] = ...) -> multiprocessing.pool.Pool: ...
def abspath(path: Union[_PathLike[AnyStr], AnyStr]) -> AnyStr: ...
def basename(path: Union[_PathLike[AnyStr], AnyStr]) -> AnyStr: ...
def catch_danglings(target_path, file_buffer) -> list: ...
def construct_db(assets_dir) -> Dict[Any, Dict[Any, Dict[Any, List[nothing]]]]: ...
def defaultHandler(val: _T0, filename: _T1, path: _T2) -> List[Tuple[Any, _T0, _T1, _T2]]: ...
def dirname(path: Union[_PathLike[AnyStr], AnyStr]) -> AnyStr: ...
def dump(obj, fp: IO[str], skipkeys: bool = ..., ensure_ascii: bool = ..., check_circular: bool = ..., allow_nan: bool = ..., cls: Optional[Type[json.encoder.JSONEncoder]] = ..., indent: Optional[Union[int, str]] = ..., separators: Optional[Tuple[str, str]] = ..., default: Optional[Callable[[Any], Any]] = ..., sort_keys: bool = ..., **kwds) -> None: ...
def exists(path: Union[_PathLike, bytes, int, str]) -> bool: ...
def field_by_path(obj, path, newval = ..., sep = ...) -> Any: ...
def file_by_assets(assets_fname, field, substitutions) -> Any: ...
def final_write(file_buffer) -> None: ...
def getSharedPath(files) -> str: ...
def get_answer(criteria) -> str: ...
def glitchDescriptionSpecialHandler(val, filename: _T1, path) -> List[Tuple[Any, Any, _T1, str]]: ...
def insort_left(a: MutableSequence[_T], x: _T, lo: int = ..., hi: int = ...) -> int: ...
@overload
def join(path: Union[bytes, _PathLike[bytes]], *paths: Union[bytes, _PathLike[bytes]]) -> bytes: ...
@overload
def join(path: Union[str, _PathLike[str]], *paths: Union[str, _PathLike[str]]) -> str: ...
def list_field_paths(obj, sep = ...) -> list: ...
def load(fp: json._Reader, cls: Optional[Type[json.decoder.JSONDecoder]] = ..., object_hook: Optional[Callable[[dict], Any]] = ..., parse_float: Optional[Callable[[str], Any]] = ..., parse_int: Optional[Callable[[str], Any]] = ..., parse_constant: Optional[Callable[[str], Any]] = ..., object_pairs_hook: Optional[Callable[[List[Tuple[Any, Any]]], Any]] = ..., **kwds) -> Any: ...
def loads(s: Union[bytearray, bytes, str], encoding = ..., cls: Optional[Type[json.decoder.JSONDecoder]] = ..., object_hook: Optional[Callable[[dict], Any]] = ..., parse_float: Optional[Callable[[str], Any]] = ..., parse_int: Optional[Callable[[str], Any]] = ..., parse_constant: Optional[Callable[[str], Any]] = ..., object_pairs_hook: Optional[Callable[[List[Tuple[Any, Any]]], Any]] = ..., **kwds) -> Any: ...
def makedirs(name: Union[_PathLike, bytes, str], mode: int = ..., exist_ok: bool = ...) -> None: ...
@overload
def normpath(path) -> Any: ...
@overload
def normpath(path: Union[_PathLike[AnyStr], AnyStr]) -> AnyStr: ...
def normpath_old(path: Union[_PathLike[AnyStr], AnyStr]) -> AnyStr: ...
def open_n_decode(filename: str, mode: str = ..., encoding: str = ..., errors: str = ..., buffering: int = ...) -> codecs.StreamReaderWriter: ...
def parseFile(filename: _T0) -> list: ...
def prepare(source) -> str: ...
def prepare_to_write(database) -> Dict[Any, Union[dict, list]]: ...
def process_label(combo) -> Tuple[str, Dict[str, Any], Dict[Any, Dict[Any, str]]]: ...
def regex(pattern: Union[Pattern[AnyStr], AnyStr], flags: int = ...) -> Pattern[AnyStr]: ...
@overload
def relpath(path: Union[bytes, _PathLike[bytes]], start: Optional[Union[bytes, _PathLike[bytes]]] = ...) -> bytes: ...
@overload
def relpath(path: Union[str, _PathLike[str]], start: Optional[Union[str, _PathLike[str]]] = ...) -> str: ...
def remove(path: Union[_PathLike, bytes, str], *, dir_fd: Optional[int] = ...) -> None: ...
def walk(top: Union[_PathLike[AnyStr], AnyStr], topdown: bool = ..., onerror: Optional[Callable[[OSError], Any]] = ..., followlinks: bool = ...) -> Iterator[Tuple[AnyStr, List[AnyStr], List[AnyStr]]]: ...
def write_file(filename, content) -> None: ...
