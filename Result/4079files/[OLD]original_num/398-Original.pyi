# (generated with --quick)

import collections
from typing import Any, Callable, DefaultDict, Deque, Dict, Iterable, Iterator, List, Optional, Sequence, Set, Sized, Tuple, Type, TypeVar, Union

HashAndSalt = Tuple[bytes, bytes]

Timestamp: Type[float]
User: Type[str]
defaultdict: Type[collections.defaultdict]
deque: Type[collections.deque]
followers: DefaultDict[str, Set[str]]
following: DefaultDict[str, Set[str]]
hashlib: module
posts: Deque[Post]
random: module
secrets: module
sys: module
time_unit_cuts: List[int]
time_units: List[Tuple[int, str]]
user_info: Dict[str, UserInfo]
user_posts: DefaultDict[str, Deque[Post]]

_T = TypeVar('_T')
_TPost = TypeVar('_TPost', bound=Post)
_TUserInfo = TypeVar('_TUserInfo', bound=UserInfo)

class Post(tuple):
    __slots__ = ["text", "timestamp", "user"]
    __dict__: collections.OrderedDict[str, Union[float, str]]
    _field_defaults: collections.OrderedDict[str, Union[float, str]]
    _field_types: collections.OrderedDict[str, type]
    _fields: Tuple[str, str, str]
    text: str
    timestamp: float
    user: str
    def __getnewargs__(self) -> Tuple[float, str, str]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[_TPost], timestamp: float, user: str, text: str) -> _TPost: ...
    def _asdict(self) -> collections.OrderedDict[str, Union[float, str]]: ...
    @classmethod
    def _make(cls: Type[_TPost], iterable: Iterable[Union[float, str]], new = ..., len: Callable[[Sized], int] = ...) -> _TPost: ...
    def _replace(self: _TPost, **kwds: Union[float, str]) -> _TPost: ...

class UserInfo(tuple):
    __slots__ = ["bio", "displayname", "email", "hashed_password", "photo"]
    __dict__: collections.OrderedDict[str, Optional[Union[str, Tuple[bytes, bytes]]]]
    _field_defaults: collections.OrderedDict[str, Optional[Union[str, Tuple[bytes, bytes]]]]
    _field_types: collections.OrderedDict[str, type]
    _fields: Tuple[str, str, str, str, str]
    bio: Optional[str]
    displayname: str
    email: str
    hashed_password: Tuple[bytes, bytes]
    photo: Optional[str]
    def __getnewargs__(self) -> Tuple[str, str, Tuple[bytes, bytes], Optional[str], Optional[str]]: ...
    def __getstate__(self) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __new__(cls: Type[_TUserInfo], displayname: str, email: str, hashed_password: Tuple[bytes, bytes], bio: Optional[str], photo: Optional[str]) -> _TUserInfo: ...
    def _asdict(self) -> collections.OrderedDict[str, Optional[Union[str, Tuple[bytes, bytes]]]]: ...
    @classmethod
    def _make(cls: Type[_TUserInfo], iterable: Iterable[Optional[Union[str, Tuple[bytes, bytes]]]], new = ..., len: Callable[[Sized], int] = ...) -> _TUserInfo: ...
    def _replace(self: _TUserInfo, **kwds: Optional[Union[str, Tuple[bytes, bytes]]]) -> _TUserInfo: ...

def age(post: Post) -> str: ...
def bisect(a: Sequence[_T], x: _T, lo: int = ..., hi: int = ...) -> int: ...
def check_user(user: str, password: str) -> bool: ...
def follow(user: str, followed_user: str) -> None: ...
def get_followed(user: str) -> List[str]: ...
def get_followers(user: str) -> List[str]: ...
def get_user(user: str) -> UserInfo: ...
def hash_password(password: str, salt: Optional[bytes] = ...) -> Tuple[bytes, bytes]: ...
def intern(string: str) -> str: ...
@overload
def islice(iterable: Iterable[_T], start: Optional[int], stop: Optional[int], step: Optional[int] = ...) -> Iterator[_T]: ...
@overload
def islice(iterable: Iterable[_T], stop: Optional[int]) -> Iterator[_T]: ...
def merge(*iterables: Iterable[_T], key: Optional[Callable[[_T], Any]] = ..., reverse: bool = ...) -> Iterable[_T]: ...
def post_message(user: str, text: str, timestamp: Optional[float] = ...) -> None: ...
def posts_by_user(user: str, limit: Optional[int] = ...) -> List[Post]: ...
def posts_for_user(user: str, limit: Optional[int] = ...) -> List[Post]: ...
def search(phrase: str, limit: Optional[int] = ...) -> List[Post]: ...
def set_user(user: str, displayname: str, email: str, password: str, bio: Optional[str] = ..., photo: Optional[str] = ...) -> None: ...
def sleep(secs: float) -> None: ...
def time() -> float: ...
