# (generated with --quick)

import array
import decimal
import enum
import io
import mmap
import struct
import time
from typing import Any, Iterable, List, Tuple, Type, Union

_Frame = Tuple[int, FrameType, Any]

BytesIO: Type[io.BytesIO]
Content: Any
Decimal: Type[decimal.Decimal]
Enum: Type[enum.Enum]
Method: Any
__all__: List[str]
datetime: Type[datetime.datetime]
error: Type[struct.error]

class FrameType(enum.Enum):
    CONTENT_BODY: int
    CONTENT_HEADER: int
    HEARTBEAT: int
    METHOD: int

class IncompleteData(Exception):
    __doc__: str

def _dump_frame(frame_type: FrameType, channel_id: int, data: bytes) -> bytes: ...
def _dump_item(value, _pack = ...) -> bytes: ...
def _load_item(stream: io.BytesIO, _unpack = ...) -> Any: ...
def _parse_frame(stream: io.BytesIO, _unpack = ...) -> Tuple[Any, FrameType, Any]: ...
def _read(stream: io.BytesIO, length: int) -> bytes: ...
def dump(fmt: str, *values, _pack = ...) -> bytes: ...
def dump_frame_content(channel_id: int, content, max_frame_size: int) -> bytes: ...
def dump_frame_heartbeat(channel_id: int) -> bytes: ...
def dump_frame_method(channel_id: int, method) -> bytes: ...
def dump_protocol_header(major: int, minor: int, revision: int) -> bytes: ...
def load(fmt: str, stream: io.BytesIO, _unpack = ...) -> list: ...
def pack(fmt: Union[bytes, str], *v) -> bytes: ...
def parse_frames(stream: io.BytesIO) -> Iterable[Tuple[int, FrameType, Any]]: ...
def parse_protocol_header(stream: io.BytesIO) -> Tuple[int, int, int]: ...
def timegm(tuple: Union[time.struct_time, Tuple[int, ...]]) -> int: ...
def unpack(fmt: Union[bytes, str], buffer: Union[bytearray, bytes, memoryview, mmap.mmap, array.array[int]]) -> tuple: ...
