# (generated with --quick)

import collections
from typing import Any, Dict, Generator, Optional, Tuple, Type, TypeVar

defaultdict: Type[collections.defaultdict]
inspect: module
itertools: module

_T = TypeVar('_T')
_TState = TypeVar('_TState', bound=State)

class Action:
    _actions: Dict[Any, Action]
    action: bool
    name: Any
    types: list
    def __call__(self, *args) -> GroundAction: ...
    def __init__(self, method) -> None: ...
    def apply(self, state, *args) -> Any: ...
    def ground(self, *args) -> GroundAction: ...
    def method(self) -> Any: ...

class GroundAction(object):
    action: Any
    args: tuple
    def __eq__(self, other) -> Any: ...
    def __init__(self, action, *args) -> None: ...
    def apply(self, s) -> Any: ...

class Object(object):
    _objects: collections.defaultdict
    name: Any
    def __eq__(self, other) -> Any: ...
    def __init__(self, name) -> None: ...
    def __repr__(self) -> Any: ...
    def __str__(self) -> Any: ...
    @staticmethod
    def get_objects_of_type(t) -> Any: ...
    @staticmethod
    def get_types() -> list: ...

class State(object):
    def action_sequence(self, length) -> Generator[Tuple[list, Any], Any, None]: ...
    def actions(self) -> Generator[str, Any, None]: ...
    def copy(self: _TState) -> _TState: ...
    def pick_action(self) -> Generator[Tuple[GroundAction, Any], Any, None]: ...
    def plan_bfs(self, goal, cur_len = ..., max_len = ...) -> Generator[list, Any, None]: ...

class UnsatisfiedPreconditions(Exception): ...

def copy(x: _T) -> _T: ...
def deepcopy(x: _T, memo: Optional[Dict[int, _T]] = ..., _nil = ...) -> _T: ...
